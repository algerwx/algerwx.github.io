[{
  "section": "Blog",
  "slug": "/blog/redis/redisson-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/",
  "title": "Redisson 使用教程",
  "description": "this is meta description",
  "date": "2025年7月20日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/redisson_hu_9e0d15d777904eaa.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"315\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/redisson_hu_1a19bd1008eb7a9d.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/redisson_hu_879379a4adc0df66.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/redisson_hu_3b1204aeb80c42fe.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "redis",
  "tags": "redisson",
  "content":"Redisson 是什么？ 定位：基于 Redis 的 Java 分布式服务框架，提供高阶 API 简化开发 核心价值 将分布式锁、队列、集合等复杂功能封装为类似 JDK 的 API 自动管理连接、序列化、故障恢复，减少样板代码 快速使用方式 1. 依赖引入（Maven） \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2. 配置 (Spring boot) application.yaml\nspring: redis: # Redisson 专有配置 redisson: file: classpath:singleRedisson.yaml singleRedisson.yaml\nsingleServerConfig: address: \u0026#34;redis://127.0.0.1:6379\u0026#34; connectionMinimumIdleSize: 5 connectionPoolSize: 50 connectTimeout: 3000 timeout: 5000 3. 注入 redisson 对象 @Autowired private RedissonClient redissonClient; 4. 分布式锁案例 public void redisLockOne() { RLock lock = redissonClient.getLock(\u0026#34;lock\u0026#34;); int tryTimes = 0; try { while (!lock.tryLock()) { tryTimes++; Thread.sleep(2000); System.out.println(\u0026#34;尝试获取锁: \u0026#34;+tryTimes); } System.out.println(\u0026#34;获取锁成功\u0026#34;); redisLockTwo(); Thread.sleep(10000); }catch (Exception e){ e.printStackTrace(); }finally { lock.unlock(); System.out.println(\u0026#34;释放锁\u0026#34;); } } 使用 redisson 很方便的实现了分布式锁。\n常见操作 ​​字符串（String）- RBucket 核心方法\nset(value): 存储字符串或对象 自动序列化 get(): 获取值 expore(duration,timeUnit): 设置过期时间 示例\npublic void set(@RequestBody RedisParm redisParm) { String key = redisParm.getKey(); String value = redisParm.getValue(); RBucket\u0026lt;String\u0026gt; bucket = redissonClient.getBucket(key); bucket.set(value, 30, TimeUnit.SECONDS); // 存储并设置30秒过期 } Hash - RMap 核心方法\nput(key,value): 添加字段 get(key): 获取值 expore(duration,timeUnit): 设置整个哈希的过期时间 示例\npublic void setHash() { RMap\u0026lt;String, Integer\u0026gt; userMap = redissonClient.getMap(\u0026#34;user:2\u0026#34;); userMap.put(\u0026#34;age\u0026#34;, 30); int age = userMap.get(\u0026#34;age\u0026#34;); System.out.println(age); } 列表（List） - RList 核心方法 add(element)：添加元素 get(index)：获取元素 remove(element)：删除元素 示例 RList\u0026lt;String\u0026gt; taskList = redissonClient.getList(\u0026#34;tasks\u0026#34;); taskList.add(\u0026#34;Task1\u0026#34;); String firstTask = taskList.get(0); 高级分布式功能​ 分布式锁（Lock） - RLock ​​核心方法​​： tryLock(waitTime, leaseTime, timeUnit)：非阻塞尝试加锁 lock()：阻塞式加锁 unlock()：释放锁 ​场景​​：秒杀库存扣减、定时任务排他执行。 ​​示例​： public void redisLockOne() { RLock lock = redissonClient.getLock(\u0026#34;lock\u0026#34;); int tryTimes = 0; try { while (!lock.tryLock()) { tryTimes++; Thread.sleep(2000); System.out.println(\u0026#34;尝试获取锁: \u0026#34;+tryTimes); } System.out.println(\u0026#34;获取锁成功\u0026#34;); redisLockTwo(); //可重入 Thread.sleep(10000); }catch (Exception e){ e.printStackTrace(); }finally { lock.unlock(); System.out.println(\u0026#34;释放锁\u0026#34;); } } private void redisLockTwo() { RLock lock = redissonClient.getLock(\u0026#34;lock\u0026#34;); System.out.println(\u0026#34;redisLockTwo 尝试获取到锁\u0026#34;); int tryTimes = 0; try { while (!lock.tryLock()) { System.out.println(\u0026#34;redisLockTwo 尝试获取到锁\u0026#34; + tryTimes++); } System.out.println(\u0026#34;redisLockTwo 获取到锁\u0026#34;); }catch (Exception e){ e.printStackTrace(); }finally { lock.unlock(); System.out.println(\u0026#34;释放锁\u0026#34;); } } 布隆过滤器 - RBloomFilter ​方法​：\ntryInit(expectedInsertions, falseProbability)：初始化 add(element), contains(element) ​场景​：大规模数据去重（如爬虫URL判重）。\n示例\nRBloomFilter\u0026lt;String\u0026gt; filter = redisson.getBloomFilter(\u0026#34;url_filter\u0026#34;); filter.tryInit(1000000L, 0.03); // 预期100万数据，3%误判率 filter.add(\u0026#34;https://example.com\u0026#34;); boolean exists = filter.contains(\u0026#34;https://example.com\u0026#34;); 延迟队列 - RDelayedQueue 方法​​：offer(element, delay, timeUnit)\n​场景​​：订单超时关闭、延迟消息通知。\n示例\nRQueue\u0026lt;String\u0026gt; queue = redissonClient.getQueue(\u0026#34;delayed_tasks\u0026#34;); RDelayedQueue\u0026lt;String\u0026gt; delayedQueue = redissonClient.getDelayedQueue(queue); delayedQueue.offer(\u0026#34;check_order\u0026#34;, 40, TimeUnit.SECONDS); "}]
